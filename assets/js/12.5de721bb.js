(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{337:function(t,s,i){"use strict";i.r(s);var n=i(4),e=Object(n.a)({},(function(){var t=this._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("p",[this._v("通常数组不直接保存值，而是通过保存值的list。然后对list中的“值”使用equals方法比较，这部分查询速度自然慢。\n但是如果有好的散列函数，数组的每个位置就只有较少的“值”。因此，不是查询所有的list，而是快速跳到数组的某个位置，只对很少的额元素进行比较，这就是HashMap会如此之快的原因。")]),this._v(" "),t("p",[this._v("这里解释一下数组的“键”，数组并不保存键本身，而是通过“键”对象生成一个数字，将其作为数组的下标索引。这个数字就是"),t("strong",[this._v("散列码")]),this._v("，有定义在Object中的hashcode生成（也称"),t("strong",[this._v("散列函数")]),this._v("）。你的类总是应该重载hashCode方法。为数组容量被固定的问题，不同的“键”可以产生不同的下标。也就是说，可能会有冲突。因此数字多大就不重要了，每个“键”总能在数组中找到他的位置。")])])}),[],!1,null,null,null);s.default=e.exports}}]);