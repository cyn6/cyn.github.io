(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{347:function(e,v,n){"use strict";n.r(v);var t=n(4),o=Object(t.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"volatile和synchronized特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#volatile和synchronized特点"}},[e._v("#")]),e._v(" volatile和synchronized特点")]),e._v(" "),v("p",[e._v("首先需要理解"),v("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[e._v("线程安全"),v("OutboundLink")],1),e._v("的两个方面："),v("strong",[e._v("执行控制")]),e._v("和"),v("strong",[e._v("内存可见")]),e._v("。")]),e._v(" "),v("p",[v("strong",[e._v("执行控制")]),e._v("的目的是控制代码执行（顺序）及是否可以并发执行。")]),e._v(" "),v("p",[v("strong",[e._v("内存可见")]),e._v("控制的是线程执行结果在内存中对其它线程的可见性。根据"),v("a",{attrs:{href:"http://blog.csdn.net/suifeng3051/article/details/52611310",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java内存模型"),v("OutboundLink")],1),e._v("的实现，线程在具体执行时，会先拷贝主存数据到线程本地（CPU缓存），操作完成后再把结果从线程本地刷到主存。")]),e._v(" "),v("p",[v("code",[e._v("synchronized")]),e._v("关键字解决的是"),v("strong",[e._v("执行控制")]),e._v("的问题，它会阻止其它线程获取当前对象的监控锁，这样就使得当前对象中被"),v("code",[e._v("synchronized")]),e._v("关键字保护的代码块无法被其它线程访问，也就无法并发执行。更重要的是，"),v("code",[e._v("synchronized")]),e._v("还会创建一个"),v("strong",[e._v("内存屏障")]),e._v("，内存屏障指令保证了所有CPU操作结果都会直接刷到主存中，从而保证了操作的"),v("strong",[e._v("内存可见")]),e._v("性，同时也使得先获得这个锁的线程的所有操作，都"),v("strong",[e._v("happens-before")]),e._v("于随后获得这个锁的线程的操作。")]),e._v(" "),v("p",[v("code",[e._v("volatile")]),e._v("关键字解决的是"),v("strong",[e._v("内存可见")]),e._v("性的问题，会使得所有对"),v("code",[e._v("volatile")]),e._v("变量的读写都会直接刷到主存，即保证了变量的可见性。这样就能满足一些对变量可见性有要求而对读取顺序没有要求的需求。")]),e._v(" "),v("p",[e._v("使用"),v("code",[e._v("volatile")]),e._v("关键字仅能实现对原始变量(如boolen、 short 、int 、long等)操作的原子性，但需要特别注意， "),v("code",[e._v("volatile")]),e._v("不能保证复合操作的原子性，即使只是"),v("code",[e._v("i++")]),e._v("，实际上也是由多个原子操作组成："),v("code",[e._v("read i; inc; write i")]),e._v("，假如多个线程同时执行"),v("code",[e._v("i++")]),e._v("，"),v("code",[e._v("volatile")]),e._v("只能保证他们操作的"),v("code",[e._v("i")]),e._v("是同一块内存，但依然可能出现写入脏数据的情况。")]),e._v(" "),v("p",[e._v("在Java 5提供了原子数据类型"),v("code",[e._v("atomic wrapper classes")]),e._v("，对它们的"),v("code",[e._v("increase")]),e._v("之类的操作都是原子操作，不需要使用"),v("code",[e._v("sychronized")]),e._v("关键字。")]),e._v(" "),v("p",[e._v("对于"),v("code",[e._v("volatile")]),e._v("关键字，当且仅当满足以下所有条件时可使用：")]),e._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("1. 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。\n2. 该变量没有包含在具有其他变量的不变式中。\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br"),v("span",{staticClass:"line-number"},[e._v("2")]),v("br")])]),v("h2",{attrs:{id:"volatile和synchronized的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#volatile和synchronized的区别"}},[e._v("#")]),e._v(" volatile和synchronized的区别")]),e._v(" "),v("ol",[v("li",[e._v("volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。")]),e._v(" "),v("li",[e._v("volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的")]),e._v(" "),v("li",[e._v("volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性")]),e._v(" "),v("li",[e._v("volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。")]),e._v(" "),v("li",[e._v("volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化")])]),e._v(" "),v("p",[e._v("如果想更好地理解这两个关键字的作用，强烈建议看一下这篇文章："),v("a",{attrs:{href:"http://blog.csdn.net/suifeng3051/article/details/52611310",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java内存模型"),v("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=o.exports}}]);